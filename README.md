## 0. 插件

https://plugins.jetbrains.com/plugin/13581-arthas-idea/versions


## 1. 火焰图

图形介绍

1. 这里的x轴代表采样总量（也就是此刻所有执行的耗时cpu的方法）。

这是注意的是x 轴并不代表时间，而是所有的调用方法合并后，按字母顺序排列。

1. Y轴代表方法的调用栈深度，每一层都是一个方法。顶部是正在执行的方法。当然调用栈越深，火焰就越高。
2. 鼠标可以点击的选中的每个框就代表了一个栈里的函数，其宽度可以直接理解为CPU时间占比（其实是采样的数量以及与采样总量的占比）。

那么，也就是说占比比较宽的框就表示：

a.该函数运行时间较长（单次时间长）

b.被调用次数较多.（调用频率高）

进而被采样的次数比较多，占用的CPU时间多 

## 2. jvm

资料；https://time.geekbang.org/column/article/14070?code=aSekYDLw0Ikh4FLNv64IV4%252Fn-Oh%252Fh396EICWSWvkZ8M%253D

资料；https://www.woshinlper.com/java/jvm/%5B%E5%8A%A0%E9%A4%90%5D%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86JVM/

### 2.1 清晰解释下 java jdk 1.8 jvm 内存空间都有啥，都是啥作用。

在 Java 运行环境中，JVM（Java Virtual Machine, Java 虚拟机）是执行 Java 程序的引擎，而内存管理是 JVM 非常重要的一部分。JDK 1.8 中的 JVM 内存空间主要分为以下几个区域，每个区域都有其特定的用途：

1. **堆（Heap）**：
   - **用途**：堆是 JVM 中内存最大的一块，用于存储所有的对象实例和数组。几乎所有对象都在此分配内存，垃圾收集器也在这里执行。
   - **分代垃圾收集机制**：堆内存被进一步划分为新生代和老年代。
     - **新生代（Young Generation）**：用于存放新创建的对象。其中又分为伊甸园区（Eden Space）和两个幸存者区（Survivor Spaces，通常称为 S0 和 S1）。
     - **老年代（Old Generation）**：用于存放生命周期较长的对象。

2. **方法区（Method Area）（在 JDK 1.8 中已被细化为元空间 Metaspace）**：
   - **用途**：存储已被加载的类元数据、常量、静态变量等。在 JDK 1.8 中，用于取代永久代（PermGen）。
   - **元空间（Metaspace）**：与永久代不同，元空间用的是本地内存而不是堆内存，这避免了 Java 中永久代容量不足导致的内存问题。

3. **栈（Stack）**：
   - **用途**：每个线程创建时会分配一个栈，它用来存储局部变量表、操作数栈、动态链接、方法出口等。栈内存会自动随着方法的进出而分配和释放。
   - **特性**：栈是线程私有的，每个线程都有自己的栈。

4. **程序计数器（Program Counter Register）**：
   - **用途**：是一个较小的内存空间，用于指示当前线程所执行的字节码的行号。
   - **特性**：它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区。

5. **本地方法栈（Native Method Stack）**：
   - **用途**：与 Java 栈类似，但它主要用于处理本地方法（Native Method）的执行。
   - **特性**：也是线程私有的，负责本地方法的调度和执行。

这些内存区的设计是为了支持 Java 的垃圾收集机制和多线程并发运行，确保 Java 应用程序能够高效和稳定地执行。了解这些内存区的功能和作用，可以帮助开发者优化 Java 应用的性能，并有效管理内存使用。

### 2.2 详细解释下 堆（Heap）以及 新生代、年老代等，包括对象在这里面的生存过程以及消亡。

在 Java 的内存管理中，堆（Heap）是一个用于为对象动态分配内存的地方。Java 程序中的所有对象和数组都在堆中分配。垃圾收集器负责在堆中回收不再被引用的对象，以便为新对象腾出空间。

为了提高垃圾回收的效率，堆进一步划分为两个主要区域：新生代（Young Generation）和老年代（Old Generation）。这些区域的分区和管理旨在优化垃圾回收过程。

### 新生代（Young Generation）

#### 分区组成：
- **伊甸区（Eden Space）**：这是新对象最初被分配的区域。
- **两个幸存者区（Survivor Spaces）**：即 S0 和 S1，存储从垃圾收集中存活下来的对象。

#### 对象的生命周期：
1. **对象创建**：新建的对象首先分配在伊甸区。
2. **第一次垃圾收集（Minor GC）**：当伊甸区满时，即会触发一次小垃圾回收（Minor GC）。存活下来的对象会被复制到一个幸存者区（若幸存者区有两个，通常从 Eden 到 S0）。
3. **对象晋升**：如果对象在幸存者区经过多次垃圾回收仍然存活（具体次数由 `MaxTenuringThreshold` 参数决定），那么它将被移动到老年代。这一过程称为晋升。

#### 新生代的特性：
- 新生代使用复制算法来进行垃圾回收，即只复制存活的对象，相对效率较高，因为大多数对象是短命的。

### 老年代（Old Generation）

#### 功能：
- 这一部分存放长生命周期的对象。当新生代的对象晋升到了一定阶段后，就会进入老年代。
  
#### 垃圾收集（Major GC / Full GC）：
- 当老年代空间耗尽时，将进行 Major GC 或 Full GC。这比 Minor GC 更加耗时，因为老年代通常包含更多的对象。
- Full GC 是对整个堆（包括老年代和新生代）进行的全面垃圾回收。

### 对象生存和消亡的整体过程：

1. **分配**：新对象在伊甸区分配内存。
2. **小垃圾回收**：当伊甸区满时，进行 Minor GC，把存活的对象移动到幸存者区。
3. **晋升**：对象经过若干次 Minor GC 后仍存活，将晋升到老年代。
4. **大垃圾回收**：在老年代空间不足时，进行 Major GC，清理那些不再被引用的对象。
5. **消亡**：被垃圾收集器清理的对象将不再占用堆内存。

### 调优策略：
- JVM 提供多个垃圾收集器（如 Serial、Parallel、CMS、G1 等）来调整堆的使用和垃圾回收的效率。
- 可以根据应用程序的特性（如响应时间、吞吐量等需求）选择合适的垃圾收集器。
- 堆大小和分代大小可以通过 JVM 参数（如 `-Xms`, `-Xmx`, `-XX:NewSize`, `-XX:MaxNewSize`）进行配置。

通过合理配置和调优，Java 的堆内存管理可以有效支持应用程序的性能和稳定性。了解对象在堆中的生存和垃圾收集过程，有助于优化应用程序内存使用并减少停顿时间。

### 2.3 你是一个java资深专家，有丰富的 jvm 开发经验。请深度讲解下 垃圾回收，以及结合场景说明具体的情况。

垃圾回收（Garbage Collection, GC）是 Java 提供的一项重要机制，通过自动管理内存，帮助开发者减少内存泄漏和手动内存管理的复杂度。通过垃圾回收，Java 自动回收不再使用的对象的内存，防止内存溢出。下面对垃圾回收进行深度讲解，并结合实际应用场景进行说明。

### 垃圾回收算法

GC 核心在于通过不同的算法来高效管理内存资源。常用的 GC 算法包括：

1. **标记-清除算法（Mark and Sweep）**：
   - **标记阶段**：遍历所有的对象引用，标记活动的对象。
   - **清除阶段**：清理掉未被标记的对象。
   - **缺点**：容易造成内存碎片，因为清除后内存是不连续的。

2. **复制算法（Copying）**：
   - 将活动的对象从一块内存（From space）复制到另一块（To space），然后清理整块 From space。
   - **优点**：内存分配简单，不会产生碎片。
   - **缺点**：需要预留多余的内存空间实行复制。

3. **标记-整理算法（Mark-Compact）**：
   - **标记阶段**：和标记-清除相似。
   - **整理阶段**：将所有活动对象移到一端，处理剩余的空间为可用。
   - 减少了碎片化问题，但相比复制算法更复杂。

4. **分代收集算法**：
   - 根据对象的生命周期不同，将堆分为新生代和老年代。
   - 新生代使用复制算法，老年代使用标记-清除 或 标记-整理。
   - **优点**：优化了大多数对象短命这一特性带来的效率。

### 垃圾收集器

Java 提供了多种垃圾收集器，适用于不同应用场景：

1. **Serial GC**：
   - 单线程收集器，非常适合单线程环境和小型应用。
   - 效率高但可能造成长时间的停顿。

2. **Parallel GC (Throughput Collector)**：
   - 多线程收集器，用于最大化 CPU 吞吐量。
   - 适合后台处理任务和高效利用系统资源的场景。

3. **CMS GC (Concurrent Mark-Sweep Collector)**：
   - 重点在于缩短停顿时间，适合响应时间敏感的应用。
   - 较轻量级的 GC，但处理老年代垃圾时效率不如 Parallel。

4. **G1 GC (Garbage-First Collector)**：
   - 设计用于大堆，提供可预测的停顿时间。
   - 将堆划分为不同的区域（Region），针对不同老化级别进行回收。

5. **ZGC / Shenandoah GC**：
   - 尝试实现低延迟垃圾回收，几乎不会造成任何长时间的停顿。

### 应用场景及配置

1. **Web 应用**：
   - 选择 CMS 或 G1 以减少响应时间的停顿。
   - 示例配置：`-XX:+UseConcMarkSweepGC`、`-XX:+UseG1GC`。

2. **批处理后台程序**：
   - 使用 Parallel GC 以提高吞吐量和CPU利用率。
   - 示例配置：`-XX:+UseParallelGC`。

3. **大数据处理**：
   - 选择 G1 GC 以应对大堆的应用。
   - 合理地调整 `-XX:G1HeapRegionSize` 和 `-XX:MaxGCPauseMillis`。

4. **实时系统**：
   - 使用 ZGC 或 Shenandoah GC，降低延迟。
   - 示例配置：`-XX:+UseZGC`、`-XX:+UseShenandoahGC`。

通过选择合适的垃圾收集器以及配置，我们可以根据应用场合优化性能和资源利用效率。了解不同算法和收集器之间的差异是成功调优的关键。每个收集器都有其特定的优势和妥协，选择取决于应用程序的需求和运行环境。


### 2.4 举例

```java
heap                                             159M            249M            1746M            9.14%           gc.ps_scavenge.count                                     8                                                       
ps_eden_space                                    147M            169M            641M             23.06%          gc.ps_scavenge.time(ms)                                  28                                                      
ps_survivor_space                                0K              6144K           6144K            0.00%           gc.ps_marksweep.count                                    2                                                       
ps_old_gen                                       11M             73M             1309M            0.91%           gc.ps_marksweep.time(ms)                                 63                                                      
nonheap                                          68M             72M             -1               94.86%                                                                                                                           
code_cache                                       12M             12M             128M             9.95%                                                                                                                            
metaspace                                        49M             52M             -1               94.31%                                                                                                                           
compressed_class_space                           6M              7M              1024M            0.63%                                                                                                                            
direct                                           0K              0K              -                200.00%                                                                                                                          
mapped 

详细介绍这些信息。
```

你提供的信息显示了一个 Java 应用程序的内存使用情况和垃圾回收统计，这些细节对性能调优和内存管理非常重要。让我们详细解释这些指标。

### 堆内存部分

1. **heap (堆内存)**：
   - **159M / 249M / 1746M**：分别表示当前已使用的堆内存、当前已分配的总堆内存，以及最大堆内存容量。
   - **9.14%**：表示当前堆内存的使用比例，相对于最大堆容量的百分比。

2. **ps_eden_space (伊甸园区)**：
   - **147M / 169M / 641M**：相似地，表示当前使用的伊甸园区内存、当前分配的伊甸园区内存，以及最大伊甸园区内存容量。
   - **23.06%**：伊甸园区使用率。

3. **ps_survivor_space (幸存区)**：
   - **0K / 6144K / 6144K**：目前没有对象存活在这个空间，当前和最大容量为 6MB。
   - **0.00%**：表示幸存区的使用率。

4. **ps_old_gen (老年代)**：
   - **11M / 73M / 1309M**：表示当前使用、已分配和最大老年代容量。
   - **0.91%**：老年代的使用比例，相对较低，表明大多数对象没有存活足够久以进入老年代。

### 非堆内存部分

1. **nonheap (非堆内存)**：
   - **68M / 72M / -1**：当前使用和最大已分配的非堆内存。
   - **94.86%**：使用率非常高，这包括类的元数据、JIT 编译后的代码等。

2. **code_cache (代码缓存区)**：
   - **12M / 12M / 128M**：当前使用、已分配和最大容量的代码缓存。
   - **9.95%**：指示 JIT 编译占用的代码缓存大小。

3. **metaspace (元空间)**：
   - **49M / 52M / -1**：负责存放类的元数据。自 Java 8 开始，Metaspace 动态调整大小。
   - **94.31%**：说明类元数据的使用情况。

4. **compressed_class_space (压缩类空间)**：
   - **6M / 7M / 1024M**：加载的类和使用的压缩类指针空间，目前使用了极小比例。
   - **0.63%**。

### 垃圾回收时间及次数

1. **gc.ps_scavenge.count**：表示新生代垃圾回收（Minor GC）的次数，当前为8。
   
2. **gc.ps_scavenge.time(ms)**：在执行新生代垃圾回收中耗费的总时间为 28 毫秒。

3. **gc.ps_marksweep.count**：表示老年代垃圾回收（Major GC 或 Full GC）的次数，当前为2。

4. **gc.ps_marksweep.time(ms)**：马克-清除算法执行花费的总时间为 63 毫秒。

### 解释与分析

- **堆内存使用**：堆内存的总使用率（9.14%）相对较低，表明堆可能被过度分配。可以根据应用需要调整。
  
- **伊甸园和幸存区**：伊甸园区有较高的使用率（23.06%），对象在这里创建，几次 Minor GC 之后对象不可达就被回收，而幸存区使用为 0%，可能意味着频繁的 Minor GC 清除了大量短生命周期对象。

- **老年代**：低使用率（0.91%）表明较少对象长期存在。

- **非堆内存使用率**：高非堆内存（尤其是元空间）使用率可能表明类加载较多，需监控以防止 Metaspace 溢出。

- **GC 性能观察**：Minor GC 相对频繁且快速（28ms），而 Major GC 的次数较少但耗时较长（63ms）。这可能是期望的行为，因 Major GC 对性能影响更大。

这些数据提供了内存和 GC 的实时视角，帮助定位性能瓶颈，并通过调整 JVM 参数改善应用表现。

### 2.5 code_cache (代码缓存区)、compressed_class_space (压缩类空间)、metaspace (元空间)，他们的用途是什么，有什么要注意的。

在 Java 虚拟机（JVM）中，非堆内存部分包括多个区域，每个区域负责存储不同种类的数据，这里重点介绍 Code Cache（代码缓存区）、Compressed Class Space（压缩类空间）和 Metaspace（元空间）的用途及注意事项。

### 1. Code Cache（代码缓存区）

**用途**：
- **JIT 编译代码**：Java 虚拟机的即时编译器（Just-In-Time Compiler，JIT）会将频繁使用的字节码编译成本地机器码，以提高运行性能。编译后的本地代码存储在代码缓存区中。
- **性能提升**：通过存储这些编译后的代码，JVM 可以避免对同一代码片段重复进行解释，从而提升执行速度。

**注意事项**：
- **内存限制**：代码缓存区有固定的最大值（可通过 `-XX:ReservedCodeCacheSize` 参数配置），需要注意在长时间运行的应用程序中这个区不会被耗尽，否则可能导致性能退化。
- **清理与优化**：JVM 在启动时和运行过程中可能会执行代码缓存的清理和优化，这个过程会对性能有一定影响。

### 2. Compressed Class Space（压缩类空间）

**用途**：
- **存储类元数据**：在开启类指针压缩的情况下（默认开启），这个空间用于存储类元数据的压缩指针，以节省内存空间。
- **支持元空间**：压缩类空间是元空间的一部分，专门用来优化类加载器的内存消耗。

**注意事项**：
- **有固定最大限制**：虽然是元空间的一部分，但压缩类空间有自己的最大内存限制（默认为 1GB），可以通过 `-XX:CompressedClassSpaceSize` 参数调整。
- **适配性告诉**：32 位 JVM 不使用压缩类空间功能，64 位 JVM 在默认情况下是开启的，因其节省的内存对大型应用尤其重要。

### 3. Metaspace（元空间）

**用途**：
- **替换永久代**：Java 8 开始，用元空间替代了永久代，用于存储类的元数据（类的结构信息、方法、字段等）。
- **动态调整大小**：与永久代不同，元空间作为物理内存的一部分，不断增长（直到达到物理内存上限），默认不设置上限，灵活性更高。

**注意事项**：
- **内存泄漏风险**：尽管更灵活，但如果不加限制，糟糕的类加载策略可能导致元空间内存泄漏。在开发环境中尤其要防止过度类加载。
- **调整与监控**：可以通过 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 进行调节，适当限制，在实际使用中密切监控。
- **自动释放**：JVM 在内存不足时会尝试回收未使用的类加载的内存，虽然一般无需手动干预，了解这方面的配置有助于优化内存使用。

这些部分的配置和监控是调优 JVM 的重要组成部分，适当的配置可以防止内存泄漏、排查性能瓶颈，并为应用程序的稳定性提供保障。
